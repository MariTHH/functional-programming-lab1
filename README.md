
## –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞ ‚Ññ1 –ø–æ F#

## –ó–∞–¥–∞—á–∏ –≠–π–ª–µ—Ä–∞ ‚Ññ7 –∏ ‚Ññ26

### –¶–µ–ª—å

–¶–µ–ª—å –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ–π —Ä–∞–±–æ—Ç—ã ‚Äî –æ—Å–≤–æ–∏—Ç—å –±–∞–∑–æ–≤—ã–µ –ø—Ä–∏—ë–º—ã –∏ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –≤ F# –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á –ø—Ä–æ–µ–∫—Ç–∞ –≠–π–ª–µ—Ä. –í —Ä–∞–º–∫–∞—Ö —Ä–∞–±–æ—Ç—ã –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–µ—à–∏—Ç—å –¥–≤–µ –∑–∞–¥–∞—á–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–µ—Ö–Ω–∏–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è:

- –ü—Ä–æ—Å—Ç–æ–π —Ä–µ–∫—É—Ä—Å–∏–∏
- –•–≤–æ—Å—Ç–æ–≤–æ–π —Ä–µ–∫—É—Ä—Å–∏–∏
- –ú–æ–¥—É–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (–≥–µ–Ω–µ—Ä–∞—Ü–∏—è, —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è, —Å–≤—ë—Ä—Ç–∫–∞)
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ `map`
- –†–∞–±–æ—Ç—ã —Å –ª–µ–Ω–∏–≤—ã–º–∏ –∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏ –∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–º–∏ —Å–ø–∏—Å–∫–∞–º–∏

---

### –û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á

1. **–ó–∞–¥–∞—á–∞ ‚Ññ7**: –ù–∞–π—Ç–∏ 10001-–µ –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ.
2. **–ó–∞–¥–∞—á–∞ ‚Ññ26**: –ù–∞–π—Ç–∏ —á–∏—Å–ª–æ `d < 1000`, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –¥–µ—Å—è—Ç–∏—á–Ω–∞—è –¥—Ä–æ–±—å \(1/d\) –∏–º–µ–µ—Ç —Å–∞–º—É—é –¥–ª–∏–Ω–Ω—É—é –ø–æ–≤—Ç–æ—Ä—è—é—â—É—é—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å.

---

## –ó–∞–¥–∞—á–∞ ‚Ññ7: –ù–∞–π—Ç–∏ 10001-–µ –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ

### –ü–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–¥–∞—á–∏

–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –Ω–∞–π—Ç–∏ 10001-–µ –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ, –∏—Å–ø–æ–ª—å–∑—É—è —Ä–∞–∑–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.

### –†–µ—à–µ–Ω–∏—è

#### 1. –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∫—É—Ä—Å–∏—è

```fsharp
let isPrime n =
    let rec check i =
        i * i > n || (n % i <> 0 && check (i + 1))
    check 2

let findPrimeRecursively count =
    let rec findPrimeInner count n =
        if count = 0 then n - 1
        else if isPrime n then findPrimeInner (count - 1) (n + 1)
        else findPrimeInner count (n + 1)
    findPrimeInner count 2

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∫—É—Ä—Å–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–≤–∞ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö –≤—ã–∑–æ–≤–∞: –æ–¥–∏–Ω –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ—Å—Ç–æ—Ç—ã —á–∏—Å–ª–∞ (isPrime), –≤—Ç–æ—Ä–æ–π –¥–ª—è –ø–æ–∏—Å–∫–∞ –Ω—É–∂–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞. –§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∫–æ–≥–¥–∞ –Ω–∞–π–¥–µ–Ω–æ 10001-–µ –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ.

- –¥–æ–ø: 
–ó–¥–µ—Å—å —É –º–µ–Ω—è –≤–æ–∑–Ω–∏–∫–ª–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∑–∞ —Å—á–µ—Ç –ø—Ä–æ–ø—É—Å–∫–∞ –ø—Ä–æ—Å—Ç—ã—Ö —á–µ—Ç–Ω—ã—Ö —á–∏—Å–µ–ª.

```fsharp
let findPrimeRecursively count =
    let rec findPrimeInner count n =
        if count = 0 then n - 1
        else if isPrime n then findPrimeInner (count - 1) (n + (if n = 2 then 1 else 2))
        else findPrimeInner count (n + (if n = 2 then 1 else 2))
    findPrimeInner count 2
```

#### 2. –•–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è

```fsharp
let findPrimeTailRecursive count =
    let rec findPrimeInner count n accumulator =
        if count = 0 then accumulator
        else if isPrime n then findPrimeInner (count - 1) (n + 1) n
        else findPrimeInner count (n + 1) accumulator
    findPrimeInner count 2 0

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–•–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –∏ –ø–µ—Ä–µ–¥–∞–µ—Ç –µ–≥–æ –¥–∞–ª—å—à–µ, –∏–∑–±–∞–≤–ª—è—è—Å—å –æ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Ö—Ä–∞–Ω–∏—Ç—å —Å—Ç–µ–∫ –≤—ã–∑–æ–≤–æ–≤.

#### 3. –ú–æ–¥—É–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ

```fsharp
let findPrimeModular count =
    Seq.initInfinite ((+) 2)
    |> Seq.filter isPrime
    |> Seq.item (count - 1)

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º `Seq.initInfinite`, —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç—Å—è –ø–æ –ø—Ä–∏–∑–Ω–∞–∫—É –ø—Ä–æ—Å—Ç–æ—Ç—ã, –∏ –æ—Ç–±–∏—Ä–∞–µ—Ç—Å—è –Ω—É–∂–Ω–æ–µ –ø–æ –ø–æ—Ä—è–¥–∫—É –ø—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ.

#### 4. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `map`

```fsharp
let findPrimeWithMap count =
    Seq.initInfinite ((+) 2)
    |> Seq.map (fun n -> if isPrime n then Some n else None)
    |> Seq.choose id
    |> Seq.item (count - 1)
    
```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–ò—Å–ø–æ–ª—å–∑—É—è `map` –∏ `choose`, –º—ã —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞ –∏ —Å–æ–∑–¥–∞–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –æ—Ç–±–∏—Ä–∞—è –Ω—É–∂–Ω–æ–µ –ø–æ –ø–æ—Ä—è–¥–∫—É —á–∏—Å–ª–æ.

#### 5. –õ–µ–Ω–∏–≤–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è

```fsharp
let findPrimeLazy count =
    Seq.initInfinite ((+) 2)
    |> Seq.filter isPrime
    |> Seq.cache
    |> Seq.item (count - 1)

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ª–µ–Ω–∏–≤–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –ø–æ–∑–≤–æ–ª—è–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö.

### —Ä–µ—à–µ–Ω–∏–µ –Ω–∞ Python

```python
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def find_nth_prime(n):
    count = 0
    num = 1
    while count < n:
        num += 1
        if is_prime(num):
            count += 1
    return num

result = find_nth_prime(10001)
print(result)  
```

## –ó–∞–¥–∞—á–∞ ‚Ññ26: –ù–∞–π—Ç–∏ —á–∏—Å–ª–æ —Å —Å–∞–º–æ–π –¥–ª–∏–Ω–Ω–æ–π –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–π—Å—è –¥–µ—Å—è—Ç–∏—á–Ω–æ–π –¥—Ä–æ–±—å—é

### –ü–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–¥–∞—á–∏

–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –Ω–∞–π—Ç–∏ —á–∏—Å–ª–æ ùëë<1000, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –¥–µ—Å—è—Ç–∏—á–Ω–∞—è –¥—Ä–æ–±—å 1/ùëë –∏–º–µ–µ—Ç —Å–∞–º—É—é –¥–ª–∏–Ω–Ω—É—é –ø–æ–≤—Ç–æ—Ä—è—é—â—É—é—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å.

### –†–µ—à–µ–Ω–∏—è

#### 1. –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∫—É—Ä—Å–∏—è

```fsharp
let findMaxCycleRecursively () =
    Seq.init 999 (fun i -> i + 2)
    |> Seq.maxBy cycleLength

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

 –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–æ—Å—Ç–∞—è —Ä–µ–∫—É—Ä—Å–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –¥–ª–∏–Ω—ã –ø–µ—Ä–∏–æ–¥–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ ùëë –∏ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è —á–∏—Å–ª–∞ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –¥–ª–∏–Ω–æ–π.

#### 2. –•–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è

```fsharp
let findMaxCycleTailRecursive () =
    let rec findMax divisor maxDivisor maxLength =
        if divisor > 1000 then maxDivisor
        else
            let currentLength = cycleLength divisor
            if currentLength > maxLength then
                findMax (divisor + 1) divisor currentLength
            else
                findMax (divisor + 1) maxDivisor maxLength
    findMax 2 0 0

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ö–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è –¥–ª—è –∏—Ç–µ—Ä–∞—Ü–∏–∏ –ø–æ –≤—Å–µ–º –¥–µ–ª–∏—Ç–µ–ª—è–º ùëë, —Å–æ—Ö—Ä–∞–Ω—è—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É –ø–µ—Ä–∏–æ–¥–∞.

#### 3. –ú–æ–¥—É–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ

```fsharp
let findMaxCycleModular () =
    let divisors = Seq.init 999 (fun i -> i + 2)
    let cycleLengths = divisors |> Seq.map cycleLength
    Seq.zip divisors cycleLengths |> Seq.maxBy snd |> fst

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –¥–µ–ª–∏—Ç–µ–ª–µ–π –∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–ª–∏–Ω –∏—Ö —Ü–∏–∫–ª–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–∞–ø–ø–∏–Ω–≥–∞ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏.

#### 4. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `map`

```fsharp
let findMaxCycleWithMap () =
    Seq.init 999 (fun i -> i + 2)
    |> Seq.map (fun d -> (d, cycleLength d))
    |> Seq.maxBy snd
    |> fst

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–° –ø–æ–º–æ—â—å—é `map` —Å–æ–∑–¥–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–∞—Ä (ùëë,–¥–ª–∏–Ω–∞–ø–µ—Ä–∏–æ–¥–∞), –ø–æ—Å–ª–µ —á–µ–≥–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞.

#### 5. –õ–µ–Ω–∏–≤–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è

```fsharp
let findMaxCycleLazy () =
    Seq.initInfinite ((+) 2)
    |> Seq.take 999
    |> Seq.map (fun d -> (d, cycleLength d))
    |> Seq.maxBy snd
    |> fst

```

##### –û–ø–∏—Å–∞–Ω–∏–µ: 

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ª–µ–Ω–∏–≤–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–º–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—è–º–∏ –∏ –≤—ã–±–æ—Ä–∫–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è.

### —Ä–µ—à–µ–Ω–∏–µ –Ω–∞ Python

```python
def cycle_length(d):
    remainders = {}
    remainder = 1 % d
    position = 0
    
    while remainder != 0 and remainder not in remainders:
        remainders[remainder] = position
        remainder = (remainder * 10) % d
        position += 1
    
    if remainder == 0:
        return 0  # –ù–µ—Ç –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–π—Å—è –¥—Ä–æ–±–∏
    else:
        return position - remainders[remainder]  # –î–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞

def find_max_cycle(limit):
    max_length = 0
    max_d = 0
    
    for d in range(2, limit):
        length = cycle_length(d)
        if length > max_length:
            max_length = length
            max_d = d
    
    return max_d

result = find_max_cycle(1000)
print(result) 
```

## –í—ã–≤–æ–¥—ã

`–û—Ç–≤–µ—Ç—ã: –Ω–∞ 7 –∑–∞–¥–∞—á—É 104743; –Ω–∞ 26 –∑–∞–¥–∞—á—É 983`

–Ø –æ–∑–Ω–∞–∫–æ–º–∏–ª–∞—Å—å —Å —è–∑—ã–∫–æ–º F#, —É–∑–Ω–∞–ª–∞ –µ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å, –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏. –°–∏–Ω—Ç–∞–∫—Å–∏—Å –∏ —Ä–∞–∑–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –Ω–µ–º–Ω–æ–≥–æ –Ω–µ–ø—Ä–∏–≤—ã—á–Ω—ã –¥–ª—è –º–µ–Ω—è, –Ω–æ —ç—Ç–æ –æ–∫–∞–∑–∞–ª–æ—Å—å –Ω–µ—Å–ª–æ–∂–Ω–æ –æ—Å–≤–æ–∏—Ç—å. –≠—Ç–∞ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞ –ø–æ–∑–≤–æ–ª–∏–ª–∞ –º–Ω–µ —É–≤–∏–¥–µ—Ç—å, –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–¥–∞—á. –Ø —Å–¥–µ–ª–∞–ª–∞ –Ω–µ–±–æ–ª—å—à–∏–µ –≤—ã–≤–æ–¥—ã, –ø–æ–∫–∞ –¥–µ–ª–∞–ª–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–µ—à–µ–Ω–∏–π:

–ù–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–æ—Å—Ç–∞—è —Ä–µ–∫—É—Ä—Å–∏—è —É–¥–æ–±–Ω–∞ –¥–ª—è –±–∞–∑–æ–≤—ã—Ö —Ä–µ—à–µ–Ω–∏–π, –∞ –º–æ–¥—É–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–µ–ª–∞–µ—Ç –∫–æ–¥ –±–æ–ª–µ–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º. –ü–æ–ø—Ä–æ–±–æ–≤–∞–ª–∞ —Ç–∞–∫–∂–µ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á –º–µ—Ç–æ–¥–∞ –∫–∞–∫ —Ö–≤–æ—Å—Ç–æ–≤—É—é —Ä–µ–∫—É—Ä—Å–∏—é, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `map` –∏ –ª–µ–Ω–∏–≤—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏.
